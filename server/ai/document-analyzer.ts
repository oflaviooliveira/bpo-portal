import OpenAI from "openai";

const openai = new OpenAI({ 
  apiKey: process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY_ENV_VAR || ""
});

export interface DocumentAnalysisResult {
  success: boolean;
  extractedData?: {
    fornecedor?: string;
    descricao?: string;
    valor?: string;
    data_vencimento?: string;
    data_pagamento?: string;
    categoria?: string;
    centro_custo?: string;
    tipo_documento?: 'PAGO' | 'AGENDADO' | 'EMITIR_BOLETO' | 'EMITIR_NF';
  };
  confidence: number;
  reasoning?: string;
  error?: string;
}

export class DocumentAnalyzer {
  
  /**
   * Analisa texto extra√≠do de documento financeiro
   */
  async analyzeDocument(
    extractedText: string, 
    filename: string, 
    documentContext?: string
  ): Promise<DocumentAnalysisResult> {
    
    if (!extractedText || extractedText.trim().length < 10) {
      return {
        success: false,
        confidence: 0,
        error: 'Texto insuficiente para an√°lise'
      };
    }

    console.log(`ü§ñ Analisando documento com IA: ${filename}`);
    console.log(`üìù Texto extra√≠do (${extractedText.length} chars): ${extractedText.substring(0, 200)}...`);

    try {
      const prompt = this.buildAnalysisPrompt(extractedText, filename, documentContext);
      
      const completion = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          {
            role: "system",
            content: `Voc√™ √© um especialista em an√°lise de documentos financeiros brasileiros. 
            Sua tarefa √© extrair informa√ß√µes estruturadas de recibos, notas fiscais, boletos e comprovantes de pagamento.
            
            CR√çTICO: Sempre responda APENAS com JSON v√°lido, sem markdown, sem explica√ß√µes.
            N√£o use \`\`\`json ou qualquer formata√ß√£o markdown na resposta.
            Seja preciso e extraia apenas informa√ß√µes claramente presentes no documento.`
          },
          {
            role: "user",
            content: prompt
          }
        ],
        temperature: 0.1,
        max_tokens: 1500
      });

      const responseText = completion.choices[0]?.message?.content;
      if (!responseText) {
        throw new Error('Resposta vazia da IA');
      }

      console.log(`ü§ñ Resposta da IA: ${responseText}`);

      // Limpar resposta removendo markdown se presente
      const cleanedResponse = responseText
        .replace(/```json\s*/g, '')
        .replace(/\s*```/g, '')
        .trim();

      console.log(`üßπ Resposta limpa: ${cleanedResponse}`);

      // Parse da resposta JSON
      const result = JSON.parse(cleanedResponse);
      
      return {
        success: true,
        extractedData: result.dados_extraidos,
        confidence: result.confianca || 0,
        reasoning: result.raciocinio
      };

    } catch (error) {
      console.error(`‚ùå Erro na an√°lise com IA: ${error}`);
      return {
        success: false,
        confidence: 0,
        error: `Erro na an√°lise: ${error}`
      };
    }
  }

  /**
   * Constr√≥i o prompt otimizado para an√°lise de documentos financeiros
   */
  private buildAnalysisPrompt(text: string, filename: string, context?: string): string {
    return `
Analise o seguinte documento financeiro e extraia as informa√ß√µes em formato JSON.

**CONTEXTO:**
- Nome do arquivo: ${filename}
- Tipo prov√°vel: ${this.inferDocumentType(filename, text)}
${context ? `- Contexto adicional: ${context}` : ''}

**TEXTO DO DOCUMENTO:**
${text}

**INSTRU√á√ïES IMPORTANTES:**
1. Extraia APENAS informa√ß√µes que est√£o claramente presentes no texto
2. Para valores monet√°rios, use o formato "R$ XX,XX" 
3. Para datas, use o formato "DD/MM/AAAA"
4. Se n√£o encontrar uma informa√ß√£o, deixe o campo vazio ""
5. Para descri√ß√£o, seja espec√≠fico e √∫til (ex: "Corrida Uber do Centro ao Aeroporto")
6. RETORNE APENAS JSON V√ÅLIDO, sem markdown, sem \`\`\`json, sem explica√ß√µes extras

**RESPOSTA ESPERADA (APENAS JSON PURO):**
{
  "dados_extraidos": {
    "fornecedor": "Nome da empresa/prestador (ex: Uber, Posto Shell)",
    "descricao": "Descri√ß√£o espec√≠fica do servi√ßo/produto",
    "valor": "Valor total pago (formato R$ XX,XX)",
    "data_vencimento": "Data de vencimento se for boleto (DD/MM/AAAA)",
    "data_pagamento": "Data do pagamento se j√° pago (DD/MM/AAAA)",
    "categoria": "Categoria do gasto (Transporte, Combust√≠vel, Alimenta√ß√£o, etc)",
    "centro_custo": "Centro de custo se identificado",
    "tipo_documento": "PAGO se j√° foi pago, AGENDADO se for para pagamento futuro, EMITIR_BOLETO ou EMITIR_NF se for emiss√£o"
  },
  "confianca": 85,
  "raciocinio": "Explica√ß√£o breve de como chegou √†s conclus√µes"
}`;
  }

  /**
   * Infere o tipo de documento baseado no filename e conte√∫do
   */
  private inferDocumentType(filename: string, text: string): string {
    const lowerFilename = filename.toLowerCase();
    const lowerText = text.toLowerCase();

    if (lowerFilename.includes('uber') || lowerText.includes('uber')) {
      return 'Recibo de transporte Uber';
    }
    if (lowerFilename.includes('nota') || lowerText.includes('nota fiscal')) {
      return 'Nota fiscal';
    }
    if (lowerFilename.includes('boleto') || lowerText.includes('boleto')) {
      return 'Boleto banc√°rio';
    }
    if (lowerFilename.includes('recibo') || lowerText.includes('recibo')) {
      return 'Recibo de pagamento';
    }
    if (lowerText.includes('comprovante')) {
      return 'Comprovante de pagamento';
    }
    
    return 'Documento financeiro';
  }

  /**
   * Valida se os dados extra√≠dos fazem sentido
   */
  validateExtractedData(data: any): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Validar valor monet√°rio
    if (data.valor && !data.valor.match(/R\$\s*\d+[,.]?\d*/)) {
      errors.push('Formato de valor monet√°rio inv√°lido');
    }

    // Validar datas
    if (data.data_pagamento && !data.data_pagamento.match(/\d{2}\/\d{2}\/\d{4}/)) {
      errors.push('Formato de data de pagamento inv√°lido');
    }

    if (data.data_vencimento && !data.data_vencimento.match(/\d{2}\/\d{2}\/\d{4}/)) {
      errors.push('Formato de data de vencimento inv√°lido');
    }

    // Validar campos obrigat√≥rios
    if (!data.fornecedor || data.fornecedor.length < 2) {
      errors.push('Fornecedor n√£o identificado ou muito curto');
    }

    if (!data.descricao || data.descricao.length < 5) {
      errors.push('Descri√ß√£o n√£o identificada ou muito curta');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}